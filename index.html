<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Make Your Own Black Hole</title>
    <style>
        body {
            margin: 0;
            background: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            width: 100%;
            position: relative;
        }
        canvas {
            width: 100%;
            height: auto;
            aspect-ratio: 4 / 3;
            display: block;
        }
        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            margin: 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px 5px 0 0;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
        }
        .controls.hidden {
            display: none;
        }
        #showControls {
            position: fixed;
            bottom: 10px;
            right: 10px;
            padding: 8px 16px;
            background: #444;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            display: none;
        }
        #showControls:hover {
            background: #666;
        }
        #textureError {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: red;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            display: none;
        }
        label {
            margin-right: 10px;
        }
        button, input[type="file"] {
            padding: 8px 16px;
            background: #444;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover, input[type="file"]:hover {
            background: #666;
        }
        input[type="file"]:disabled {
            background: #888;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <div id="textureError">Failed to load default textures. Please check file paths or server setup.</div>
    <div class="controls">
        <button id="toggleControls">Hide Controls</button>
        <label for="diskTexture">Disk Texture:</label>
        <input type="file" id="diskTexture" accept="image/*">
        <label for="backgroundTexture">Background Texture:</label>
        <input type="file" id="backgroundTexture" accept="image/*">
        <button id="toggleAnimation">Save my Framerate!</button>
    </div>
    <button id="showControls">Show Controls</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');
        if (!gl) {
            alert('WebGL is not supported by your browser.');
            throw new Error('WebGL not supported');
        }

        // Vertex shader
        const vsSource = `
            attribute vec2 a_position;
            varying vec2 v_uv;
            void main() {
                v_uv = (a_position + 1.0) * 0.5;
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        // Fragment shader
        const fsSource = `
            precision highp float;
            uniform vec2 iResolution;
            uniform float iTime;
            uniform sampler2D iChannel0;
            uniform sampler2D iChannel1;
            varying vec2 v_uv;

            #define PI 3.1415926538
            float camR = 30.0;
            float tilt = 0.1;
            float zoom = 1.5;
            float a = 0.6;
            float discMin = 3.83 * 0.75;
            float discMax = 15.0 * 0.75;
            float eps = 0.02;
            float dtau = 0.2;
            const int maxSteps = 200;

            mat4 inverse(mat4 m) {
                float
                    a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],
                    a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],
                    a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],
                    a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],

                    b00 = a00 * a11 - a01 * a10,
                    b01 = a00 * a12 - a02 * a10,
                    b02 = a00 * a13 - a03 * a10,
                    b03 = a01 * a12 - a02 * a11,
                    b04 = a01 * a13 - a03 * a11,
                    b05 = a02 * a13 - a03 * a12,
                    b06 = a20 * a31 - a21 * a30,
                    b07 = a20 * a32 - a22 * a30,
                    b08 = a20 * a33 - a23 * a30,
                    b09 = a21 * a32 - a22 * a31,
                    b10 = a21 * a33 - a23 * a31,
                    b11 = a22 * a33 - a23 * a32,

                    det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

                if (abs(det) < 1e-6) return mat4(0.0);

                return mat4(
                    a11 * b11 - a12 * b10 + a13 * b09,
                    -a01 * b11 + a02 * b10 - a03 * b09,
                    a31 * b05 - a32 * b04 + a33 * b03,
                    -a21 * b05 + a22 * b04 - a23 * b03,

                    -a10 * b11 + a12 * b08 - a13 * b07,
                    a00 * b11 - a02 * b08 + a03 * b07,
                    -a30 * b05 + a32 * b02 - a33 * b01,
                    a20 * b05 - a22 * b02 + a23 * b01,

                    a10 * b10 - a11 * b08 + a13 * b06,
                    -a00 * b10 + a01 * b08 - a03 * b06,
                    a30 * b04 - a31 * b02 + a33 * b00,
                    -a20 * b04 + a21 * b02 - a23 * b00,

                    -a10 * b09 + a11 * b07 - a12 * b06,
                    a00 * b09 - a01 * b07 + a02 * b06,
                    -a30 * b03 + a31 * b01 - a32 * b00,
                    a20 * b03 - a21 * b01 + a22 * b00
                ) / det;
            }

            mat4 diag(vec4 vec) {
                return mat4(
                    vec.x, 0.0, 0.0, 0.0,
                    0.0, vec.y, 0.0, 0.0,
                    0.0, 0.0, vec.z, 0.0,
                    0.0, 0.0, 0.0, vec.w
                );
            }

            float rFromCoords(vec4 pos) {
                vec3 p = pos.yzw;
                float rho2 = dot(p, p) - a * a;
                float r2 = 0.5 * (rho2 + sqrt(rho2 * rho2 + 4.0 * a * a * p.z * p.z));
                return sqrt(r2);
            }

            mat4 metric(vec4 pos) {
                float r = rFromCoords(pos);
                vec4 k = vec4(-1.0, (r * pos.y - a * pos.z) / (r * r + a * a), (r * pos.z + a * pos.y) / (r * r + a * a), pos.w / r);
                float f = 2.0 * r / (r * r + a * a * pos.w * pos.w / (r * r));
                return f * mat4(k.x * k, k.y * k, k.z * k, k.w * k) + diag(vec4(-1.0, 1.0, 1.0, 1.0));
            }

            float hamiltonian(vec4 x, vec4 p) {
                mat4 invMetric = inverse(metric(x));
                return 0.5 * dot(invMetric * p, p);
            }

            vec4 hamiltonianGradient(vec4 x, vec4 p) {
                return (vec4(
                    hamiltonian(x + vec4(eps, 0.0, 0.0, 0.0), p),
                    hamiltonian(x + vec4(0.0, eps, 0.0, 0.0), p),
                    hamiltonian(x + vec4(0.0, 0.0, eps, 0.0), p),
                    hamiltonian(x + vec4(0.0, 0.0, 0.0, eps), p)
                ) - hamiltonian(x, p)) / eps;
            }

            void transportStep(inout vec4 x, inout vec4 p) {
                float stepsize = dtau;
                p -= stepsize * hamiltonianGradient(x, p);
                x += stepsize * inverse(metric(x)) * p;
            }

            bool stopCondition(vec4 pos) {
                float r = rFromCoords(pos);
                return r < 1.0 + sqrt(1.0 - a * a) || r > max(2.0 * camR, 30.0);
            }

            vec4 unit(vec4 vec, mat4 g) {
                float norm2 = dot(g * vec, vec);
                if (norm2 != 0.0) {
                    return vec / sqrt(abs(norm2));
                }
                return vec;
            }

            mat4 tetrad(vec4 x, vec4 time, vec4 aim, vec4 vert) {
                mat4 g = metric(x);
                vec4 E0 = unit(time, g);
                vec4 E1 = unit(aim + dot(g * aim, E0) * E0, g);
                vec4 E3 = unit(vert - dot(g * vert, E1) * E1 + dot(g * vert, E0) * E0, g);
                vec4 E2 = unit(inverse(g) * vec4(
                    dot(E0.yzw, cross(E1.yzw, E3.yzw)),
                    -dot(E0.zwx, cross(E1.zwx, E3.zwx)),
                    dot(E0.wxy, cross(E1.wxy, E3.wxy)),
                    -dot(E0.xyz, cross(E1.xyz, E3.xyz))
                ), g);
                return mat4(E0, E1, E2, E3);
            }

            void main() {
                vec2 uv = (2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.x;
                tilt = sin(iTime * 0.1) * 0.3;

                float x = sqrt(camR * camR + a * a) * cos(tilt);
                float z = camR * sin(tilt);
                vec4 camPos = vec4(0.0, x, 0.0, z);

                vec4 time = vec4(1.0, 0.0, 0.0, 0.0);
                vec4 aim = vec4(0.0, x, 0.0, z);
                vec4 vert = vec4(0.0, -x * z, 0.0, x * x) * sign(cos(tilt));
                mat4 axes = tetrad(camPos, time, aim, vert);

                vec4 pos = camPos;
                vec3 dir = normalize(vec3(-zoom, uv));
                vec4 dir4D = -axes[0] + dir.x * axes[1] + dir.y * axes[2] + dir.z * axes[3];

                bool captured = false;
                bool hitDisc = false;
                vec4 intersectPos;
                vec2 discUV;
                float blueshift;

                vec4 p = metric(pos) * dir4D;
                for (int i = 0; i < maxSteps; i++) {
                    vec4 lastpos = pos;
                    transportStep(pos, p);
                    if (pos.w * lastpos.w < 0.0) {
                        intersectPos = (pos * abs(lastpos.w) + lastpos * abs(pos.w)) / abs(lastpos.w - pos.w);
                        float r = rFromCoords(intersectPos);
                        if (r > discMin && r < discMax) {
                            hitDisc = true;
                            discUV = (intersectPos.yz / discMax + 1.0) * 0.5;
                            float angle = iTime * 0.2;
                            float s = sin(angle);
                            float c = cos(angle);
                            discUV -= 0.5;
                            discUV = vec2(discUV.x * c - discUV.y * s, discUV.x * s + discUV.y * c);
                            discUV += 0.5;
                            vec4 discVel = vec4(r + a / sqrt(r), vec3(-intersectPos.z, intersectPos.y, 0.0) * sign(a) / sqrt(r)) / sqrt(r * r - 3.0 * r + 2.0 * a * sqrt(r));
                            blueshift = 1.0 / dot(p, discVel);
                            break;
                        }
                    }
                    if (stopCondition(pos)) {
                        float r = rFromCoords(pos);
                        captured = r < 1.0 + sqrt(1.0 - a * a);
                        break;
                    }
                }

                if (captured) {
                    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                } else if (hitDisc) {
                    vec4 diskTexColor = texture2D(iChannel1, discUV);
                    gl_FragColor = vec4(diskTexColor.rgb * pow(blueshift, 3.0), 1.0);
                } else {
                    vec2 flippedUV = vec2(v_uv.x, 1.0 - v_uv.y);
                    gl_FragColor = texture2D(iChannel0, flippedUV);
                }
            }
        `;

        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                const log = gl.getShaderInfoLog(shader);
                console.error(`Shader compilation error (${type === gl.VERTEX_SHADER ? 'vertex' : 'fragment'}): ${log}`);
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = compileShader(vsSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fsSource, gl.FRAGMENT_SHADER);

        if (!vertexShader || !fragmentShader) {
            alert('Failed to compile shaders. Check console for details.');
            throw new Error('Shader compilation failed');
        }

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program linking error:', gl.getProgramInfoLog(program));
            alert('Failed to link shader program. Check console for details.');
            throw new Error('Program linking failed');
        }

        gl.useProgram(program);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1,
        ]);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        const resolutionLocation = gl.getUniformLocation(program, 'iResolution');
        const timeLocation = gl.getUniformLocation(program, 'iTime');

        let isAnimating = true;
        let lastTime = performance.now();
        const toggleButton = document.getElementById('toggleAnimation');
        toggleButton.addEventListener('click', () => {
            isAnimating = !isAnimating;
            toggleButton.textContent = isAnimating ? 'Save my Framerate!' : 'Resume Animation';
            if (isAnimating) {
                lastTime = performance.now();
                render();
            }
        });

        const controls = document.querySelector('.controls');
        const toggleControlsButton = document.getElementById('toggleControls');
        const showControlsButton = document.getElementById('showControls');
        toggleControlsButton.addEventListener('click', () => {
            controls.classList.add('hidden');
            showControlsButton.style.display = 'block';
        });
        showControlsButton.addEventListener('click', () => {
            controls.classList.remove('hidden');
            showControlsButton.style.display = 'none';
        });

        let diskTexture = null;
        let backgroundTexture = null;
        const diskTextureInput = document.getElementById('diskTexture');
        const backgroundTextureInput = document.getElementById('backgroundTexture');
        const textureError = document.getElementById('textureError');

        function createFallbackTexture(unit) {
            const texture = gl.createTexture();
            gl.activeTexture(gl.TEXTURE0 + unit);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            const pixel = new Uint8Array([255, 255, 255, 255]); // White pixel
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.uniform1i(gl.getUniformLocation(program, unit === 0 ? 'iChannel0' : 'iChannel1'), unit);
            return texture;
        }

        function createTextureFromImage(image, type, unit) {
            console.log(`Creating texture for unit ${unit} with image dimensions ${image.width}x${image.height}`);
            gl.activeTexture(gl.TEXTURE0 + unit);
            const texture = gl.createTexture();
            gl.bindTexture(type, texture);
            gl.texImage2D(type, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
            if (gl.getError() !== gl.NO_ERROR) {
                console.error(`WebGL error when creating texture for unit ${unit}`);
                return null;
            }
            gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(type, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(type, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.uniform1i(gl.getUniformLocation(program, unit === 0 ? 'iChannel0' : 'iChannel1'), unit);
            return texture;
        }

        // Default texture URLs
        const defaultDiskTextureUrl = 'https://res.cloudinary.com/dadjewcmh/image/upload/v1755036799/oj8vbrw2hbb0kzzywpfo.png';
        const defaultBackgroundTextureUrl = 'https://res.cloudinary.com/dadjewcmh/image/upload/v1755219943/wxs5irpnqxr6d10jybqu.jpg';

        function loadDefaultTexture(url, unit, callback) {
            if (!url) {
                console.warn(`No default texture URL provided for unit ${unit}`);
                callback(createFallbackTexture(unit));
                return;
            }
            const image = new Image();
            image.crossOrigin = 'anonymous';
            image.onload = () => {
                console.log(`Successfully loaded texture from ${url}`);
                const texture = createTextureFromImage(image, gl.TEXTURE_2D, unit);
                callback(texture || createFallbackTexture(unit));
            };
            image.onerror = () => {
                console.error(`Failed to load default texture from ${url}. Using fallback.`);
                textureError.style.display = 'block';
                callback(createFallbackTexture(unit));
            };
            image.src = url;
        }

        // Load default textures
        loadDefaultTexture(defaultDiskTextureUrl, 1, (texture) => {
            diskTexture = texture;
            backgroundTextureInput.disabled = !diskTexture;
        });
        loadDefaultTexture(defaultBackgroundTextureUrl, 0, (texture) => {
            backgroundTexture = texture;
        });

        diskTextureInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const image = new Image();
                image.onload = () => {
                    if (diskTexture) gl.deleteTexture(diskTexture);
                    diskTexture = createTextureFromImage(image, gl.TEXTURE_2D, 1);
                    backgroundTextureInput.disabled = false;
                    textureError.style.display = 'none'; // Hide error on successful upload
                };
                image.src = URL.createObjectURL(file);
            }
        });

        backgroundTextureInput.addEventListener('change', (e) => {
            if (!diskTexture) {
                alert('Please upload a disk texture first.');
                e.preventDefault();
                backgroundTextureInput.value = '';
                return;
            }
            const file = e.target.files[0];
            if (file) {
                const image = new Image();
                image.onload = () => {
                    if (backgroundTexture) gl.deleteTexture(backgroundTexture);
                    backgroundTexture = createTextureFromImage(image, gl.TEXTURE_2D, 0);
                    textureError.style.display = 'none'; // Hide error on successful upload
                };
                image.src = URL.createObjectURL(file);
            }
        });

        let startTime = performance.now();
        const targetFPS = 30;
        const frameInterval = 1000 / targetFPS;

        function resizeCanvas() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const aspect = 4 / 3;
            let canvasWidth, canvasHeight;

            if (width / height > aspect) {
                canvasHeight = height;
                canvasWidth = canvasHeight * aspect;
            } else {
                canvasWidth = width;
                canvasHeight = canvasWidth / aspect;
            }

            canvas.style.width = `${canvasWidth}px`;
            canvas.style.height = `${canvasHeight}px`;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        function render(currentTime) {
            if (!isAnimating) return;

            if (currentTime - lastTime >= frameInterval) {
                resizeCanvas();
                gl.clear(gl.COLOR_BUFFER_BIT);

                gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
                gl.uniform1f(timeLocation, (currentTime - startTime) / 1000);

                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                lastTime = currentTime - (currentTime - lastTime) % frameInterval;
            }

            requestAnimationFrame(render);
        }

        window.addEventListener('resize', () => {
            resizeCanvas();
            if (isAnimating) render(performance.now());
        });

        resizeCanvas();
        render(performance.now());
    </script>
</body>
</html>
